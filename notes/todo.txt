
- Figure out why I had to use "int" type instead of "bool" in the Mac class.
    I think I have to use "bint" as there is no bool.

- We can actually split everything into modules, if we do all the cdef extern
  declarations in a single module. could have mac-core.xd.inc.mako which is
  the Mako template for the pxd include for the core.

  The easy part is rearranging the existing files so all the extern defs are
  in the core. The hard part is importing everything that we want back into
  the modules.

- Make notes that this is for Python2.X, not 3, which uses byte arrays.

- Things to add:
	- ctr mode flags (page 38 of pdf):
		CTR COUNTER LITTLE ENDIAN
		CTR COUNTER BIG ENDIAN
		LTC CTR RFC3686
	- call cipher done function: We may not see the need for it, but lots of
	  other things may
		- we need to provide for this to be done manually, as eax actually
		  returns a value from this.
		- automatically call it if it wasnt already called
		- maybe need to check in all the other functions if it has been called
		  ; test to see if it explodes
	- Add cipher auth modes:
		- EAX on pdf page 46
			- has extra nonce and header in init call
			- extra eax_addheader function
			- the done call has a length for the eax tag.
		- OCB on pdf page 50
			- has extra nonce in the init (same length as block size)
			- ocb_encrypt/decrypt assume the length to be the block size.
			  hopefully the descriptor functions do not do the same thing
			- the done does different things for encrypt/decrypt... nasty
			- has convenient functions to do all of this
		- CCM on pdf page 53
			- it is only for packet mode, so only the memory function exists
		- GCM on pdf page 56
			- init is the same
			- adds a `gcm_add_iv` function which should be called as the step
			  after init
			- adds a `gcm_add_aad` function which should be called after adding
			  the iv and before encrypting. need not be called for security
			  reasons
			- crypting is done with the `gcm_process` function.
			- done also outputs here
	- Document the crazy way the copy function works, and that it may not
	  be the nicest thing to be doing.
	- expose the hash oid via the descriptor and `find_hash_oid`
		unsigned long OID[16] and unsigned long OIDlen
	- use the hash_memory, hash_file, and hash_filehandle on the descriptor
	  class
	- make sure copy works fine for chc
	- test that we can use two chcs at the same time through each other
	- use the hmac_memory and hmac_file on the mac descriptor. is there a
	  hmac_filehandle as well? there is also a set for omac, pmac, xcbc, f9...
	  pelican didn't say
	- implement pelican and f9 macs from pdf page 69 and 73
	- prng import/export on page 78. the descriptor has an ine export_size
	  which indicates the length. descriptor has import/export functions as
	  well on page 191
	- perhaps export rng_get_bytes as it's own thing
	- consider naming the secure rng "srng" or "sys" or something
	- pkcs1 module
		- rsa pkcs1.5 padding on pdf page 101
		- rsa oaep in 103
		- rsa pss on 105
	- expose rsa_exptmod in a more obvious way (maybe); page 108
	- add the lparam arg to oaep
	- ecc; evertyhing! page 117
		- keysize in bits should round up.
	- consider having rsa key generation round the bits up to the next byte
	  automatically
	- dsa, everything! page 129
	- asn1, everything! page 137
		- is this really nessesary?...
	- reconsider the defaults I have given to all of the functions (ie pkcs5)
	- base64 is on page 156, but seems unnessesary
	- is_prime and rand_prime on page 157
	- note that the same thread safety concerns exist as with the base library
	- note that I am not bothering to implement the accelerated cipher functions
	- note that I am not bother to wrap the math descriptors

- Consider adding a copy() method to ciphers.

- cleanup the test output so it is easier to see at a glance what is going on
	- consider using unittest module

- write documentation
	- with doctest!

- decide if the RSAKey constructor will take a bit size or byte size.
	for bit size:
		This is what everyone thinks in.
		Makes it easier for us to work with non mod 8 keys. (Because we aren't
		 lulled into a false sense of security)
	for byte size:
		This is what tomcrypt actually works with internally.


- Figure out what is up with the constant which controls error handling.
	See if I can get it to just error and not throw anything. setting ARGTYPE
	to 4 SHOULD result in errors being returned.

- implement the rest of the rsa functions
	- padding / unpadding

- implement ecc and dsa
	- just do it with whatever tom gives me... openssl doesnt do it



- figure out which parts actually need to be bundled together
	1: rsa / math / prng
	2: cipher / hash / mac / pkcs5

