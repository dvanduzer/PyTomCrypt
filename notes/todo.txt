
- Really need to improve on the readme.

- explicit PRNG.done()
- PRNG descriptors

- add Cipher.copy ?
- add tests for everything in the readme

- write a timing-attack-safe string comparison function


- options for fixing the linking issues:
	1) Use this trick, but it won't ever work with Windows and I feel that 
	there could be symbol collisions in the future unless I prefix all my 
	variables names, etc. 
	2) Develop more specific platform-dependent fixes (special linking per 
	platform, etc) 
	3) Jam everything together into the one main core module, and write 
	pure Python modules to import the right parts and provide tiny 
	wrappers to restore the class naming, etc. 
	I'm going to leave it at option 1 for today because it is working on 
	the two platforms that I absolutely need it to. Do you feel that 
	option 2 is a viable alternative or will I eventually have to go to 
	option 3?

- Start a README.markdown:
	- basic examples
	- things that are missing
	- things that I have purposefully omitted:
		- memory functions
	- things that I have changed
	- build instructions (for installation and development)
	- bits vs bytes for asymmetric key sizes.

- Standardize on *_length vs *_len vs *_size. The problem with this is that
sometimes it feels more natural to use one than the other. While there may be
value in trying to make it uniform, the purpose of this project is not to get
the API to the point where it is trivially memorizable. There is also, perhaps,
value in refactoring the original API to something more Python like, but
keeping naming schemes exactly the way they are to the original documentation
still applies.

- Look into the Cython optimization configuration options.

- Restore all of the constructor functions.


- The memory encrypt/decrypt/hash functions can be methods of the descriptors.
I actually don't think I'm even going to bother implementing them for the
moment.

- Make notes that this is for Python2.X, not 3, which uses byte arrays.

- Things to add:
	- ctr mode flags (page 38 of pdf):
		CTR COUNTER LITTLE ENDIAN
		CTR COUNTER BIG ENDIAN
		LTC CTR RFC3686
	- call cipher done function: We may not see the need for it, but lots of
	  other things may
		- we need to provide for this to be done manually, as eax actually
		  returns a value from this.
		- automatically call it if it wasnt already called
		- maybe need to check in all the other functions if it has been called
		  ; test to see if it explodes
	- Add cipher auth modes:
		- EAX on pdf page 46
			- has extra nonce and header in init call
			- extra eax_addheader function
			- the done call has a length for the tag, and returns the tag.
			Perhaps I should standardize that the done call returns a string
			but for nearly everything it will return an empty string. Since
			done currently returns nothing, all this does is unify the API so
			that code simply have to concat everything together, regardless
			of the type of value this returns.
		- OCB on pdf page 50
			- has extra nonce in the init (same length as block size)
			- ocb_encrypt/decrypt assume the length to be the block size.
			  hopefully the descriptor functions do not do the same thing
			- the done does different things for encrypt/decrypt... nasty
			- has convenient functions to do all of this
		- CCM on pdf page 53
			- it is only for packet mode, so only the memory function exists.
			I would still have this expose exactly the same API, however. The
			constructor would simply hold onto the key and cipher, while the
			encrypt/decrypt methods would use this special function.
		- GCM on pdf page 56
			- init is the same
			- adds a `gcm_add_iv` function which should be called as the step
			  after init
			- adds a `gcm_add_aad` function which should be called after adding
			  the iv and before encrypting. need not be called for security
			  reasons
			- crypting is done with the `gcm_process` function.
			- done also outputs here
	- Document the crazy way the copy function works, and that it may not
	  be the nicest thing to be doing.
	- expose the hash oid via the descriptor and `find_hash_oid`
		unsigned long OID[16] and unsigned long OIDlen
	- use the hash_memory, hash_file, and hash_filehandle on the descriptor
	  class
	- make sure copy works fine for chc
	- test that we can use two chcs at the same time through each other
	- use the hmac_memory and hmac_file on the mac descriptor. is there a
	  hmac_filehandle as well? there is also a set for omac, pmac, xcbc, f9...
	  pelican didn't say
	- implement pelican and f9 macs from pdf page 69 and 73
	- prng import/export on page 78. the descriptor has an ine export_size
	  which indicates the length. descriptor has import/export functions as
	  well on page 191
	- perhaps export rng_get_bytes as it's own thing
	- consider naming the secure rng "srng" or "sys" or something
	- pkcs1 module
		- rsa pkcs1.5 padding on pdf page 101
		- rsa oaep in 103
		- rsa pss on 105
	- expose rsa_exptmod in a more obvious way (maybe); page 108
	- add the lparam arg to oaep
	- ecc; evertyhing! page 117
		- keysize in bits should round up.
	- consider having rsa key generation round the bits up to the next byte
	  automatically
	- dsa, everything! page 129
	- asn1, everything! page 137
		- is this really nessesary?...
	- reconsider the defaults I have given to all of the functions (ie pkcs5)
	- base64 is on page 156, but seems unnessesary
	- is_prime and rand_prime on page 157
	- note that the same thread safety concerns exist as with the base library
	- note that I am not bothering to implement the accelerated cipher functions
	- note that I am not bother to wrap the math descriptors

- Consider adding a copy() method to ciphers.

- cleanup the test output so it is easier to see at a glance what is going on
	- consider using unittest module

- write documentation
	- with doctest!

- decide if the RSAKey constructor will take a bit size or byte size.
	for bit size:
		This is what everyone thinks in.
		Makes it easier for us to work with non mod 8 keys. (Because we aren't
		 lulled into a false sense of security)
	for byte size:
		This is what tomcrypt actually works with internally.


- Figure out what is up with the constant which controls error handling.
	See if I can get it to just error and not throw anything. setting ARGTYPE
	to 4 SHOULD result in errors being returned.

- implement the rest of the rsa functions
	- padding / unpadding

- implement ecc and dsa
	- just do it with whatever tom gives me... openssl doesnt do it



