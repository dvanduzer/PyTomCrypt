
How to dispatch to the differing methods for each mode:
    1. Dispatch to the different methods in Python.
        - Takes about 300 ns per block.
    2. Build a class for each of the modes. The dispatching is done before it
       even compiles.
        - Takes about 292-294 ns per block.
    3. Save pointers to the en/decrypt functions in the Cipher class.
        - This relies upon the compiler automatically casting from void* to
          whatever it should be (symetric_XXX*)
        - Takes about 295 ns per block.
    4. Build array of pointer functions and store the index into that array in
       the class. No more malloc!
        - Still relies upon the compiler doing the right thing with void*
        - Takes about 292-293 per block.



Organize this into a standard package layout:
    PyTomCrypt/
        tomcrypt/
            __init__.py
            <everything here>
        setup.py
        libtomcrypt-...
        README.txt
        LICENSE.txt

Stop thinking about making the ciphers register when you need them. It takes
only 83 microseconds to register them all.



Add: EAX (page 46), PCB(50), CCM(53), and GCM(56)



Purge the git history using a index-filter:
    Remove libtomcrypt, lib, include, .Python, bin, build, *.c, *.so, the .pyx
    files after a .mako file exists, .pyx when a .pyx exists

implement CHC hashing:
	a CHCHash class will need to call chc_register before every update
	